
# 4. 头文件保护

## 方法一

只要在头文件中加上 `#pragma once` 即可。

这是一条以 `#` 开头的语句。和 `#include` 一样，这也是一条预处理器指令。

它的作用是，保证头文件只被包含一次，即使多次包含也不会造成重复声明。

### 缺点

但是，`#pragma once` 也有缺点：

1. 由编译器保证，即可能会遇到不支持 `#pragma once` 的编译器。不过现在大部分编译器都支持，所以不用过于担心，除非您用的是一些旧版本的编译器，或是一些特别冷门的编译器。

2. 只能保证这个头文件不被包含，而不是保证这里面的内容不被包含。即如果这个头文件有副本，那么源文件和副本之间将无法起到防护作用。

### 解决缺点

1. 尽量使用新版本的、流行的编译器。

2. 尽量在不同文件中引入的是同一个头文件，而不是副本。

## 方法二

方法二是更早期的方法（早在 C 语言中就有使用），本质是利用宏加入 include 防范。

该方法的兼容性好，支持早期编译器。本文使用的便是这个方案。

### 原理

引入后判断是否定义了某个宏，如果定义了就跳过该头文件。

如果没定义这个宏，该文件将不会被跳过。

在该头文件中会定义这个宏。

### 实现

>（在头文件保护中）通常习惯以 `_H__` 作为后缀。由于 leptjson 只有一个头文件，可以简单命名为 `LEPTJSON_H__`。如果项目有多个文件或目录结构，可以用 `项目名称_目录_文件名称_H__` 这种命名方式。

为什么要加后缀？因为定义的宏不可以重名，为了防止宏名冲突，一般加上这个后缀。

```cpp
// 判断是否没有定义 LEPTJSON_H
ifndef LEPTJSON_H__
    // 如果没有定义，执行定义语句
    #define LEPTJSON_H__

// 头文件原本的内容

endif /*LEPTJSON_H__*/
       // 结束判断，同时通常习惯 #endif 后加上宏的名字
```

### 缺陷与解决方案

缺陷：

多次引入后，会大大增大文件的体积，使编译速度变慢。

解决方案：

只需引入的文件小一点即可。

```cpp
// a.cpp
include "h.hpp"
```

```cpp
// h.hpp
ifndef H_H__

    #include "./h/h.hpp"

endif /* H_H__ */
```

```cpp
// ./h/h.hpp
ifndef H_H__
define H_H__

/* */

endif /* H__ */
```

看上去没有减少多少（甚至还变多了一点）。但是你想想我们 `#include <iostream>` 后产生了多大的文件？用此方法可以有效防止编译速度变慢。

不过，这种方法比较复杂，建议在一些大项目中使用，小项目减少的编译速度并不明显。

本文的附录简单介绍了这些以 `#` 开头的预处理器指令（[附录 2. 一些预处理器指令](./附录_02_一些预处理器指令)）。

## C++ 之父的观点

C++ 之父认为（在 C++ 中）：

>除非万不得已，否则不要使用宏。
>
>我建议，只有在条件编译，尤其是执行包含文件保护的任务时再使用宏。
>
>如果可能，尽量避免使用 `#pragma`
>
>不要使用宏。
>
>如果必须使用宏，一定要用很多大写组成宏的名字，尽管这样的名字看起来会很丑陋。
>
>《C++ 程序设计语言（第 1 ~ 3 部分）》（原书第四版）/（美）本贾尼·斯特劳斯特卢普（Bjarne Stroustrup）著；王刚，杨巨峰译。——北京：机械工业出版社，2016.6

## “奇技淫巧”

给大家看个乐子（来自 [csdn](<https://blog.csdn.net/weixin_41055260/article/details/122994997>)）：

```cpp
pragma once
ifndef H_H__
    #define H_H__
// ...
endif
```

看起来这是想兼有上述方法一和方法二的优点。不过只要使用了 `#ifndef` 就会有宏名冲突的危险，也无法避免不支持 `#pragma once` 的编译器报错，所以混用两种方法似乎不能带来更多的好处，倒是会让一些不熟悉的人感到困惑。

## 模块

C++ 20 中引入了一个新特性：模块（module）。可惜现在的支持还不是很完善（可以用，但不是特别好用）。因此暂时不使用模块。

据说，使用模块可以减少重复编译，提高编译速度。
