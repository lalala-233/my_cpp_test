# 5. 二十以内加减法

## 1+1

还记得吗？我们的目的是做一个计算器。

所以，我们需要从输入中获取我们所要计算的内容。

当然，代码最好放在命名空间中。本文的命名空间为 Parser。

先假定一下输入的内容，先做加法。假设接收到的数据全是 `"x+y"` 这种结构（即 x 和 y 为 0~9 之间的整数），没有空格等其它干扰。

那么我们可以轻松地写一个函数来返回结果（parser 意为解析器）。

```cpp
int parser(const std::string& content);   // 可以试着自己实现一下
```

但是 `std::string` 写起来有点麻烦，所以我们可以加入一行 `using std::string;`。不过，这一行要写在命名空间里，这样就不会造成命名空间污染。

这个函数添加了 `&` 表示引用，使用引用可以避免拷贝（或者叫做深拷贝）的产生，对程序起到优化作用。如果你不理解，可以删除，只会降低少量性能。

一般来说，如果不是专门用于修改实参的函数，不管会不会改变实参，只要使用引用，都应该加上 const，表示不会修改该变量的值。这是一个良好的习惯。

## 测试函数

上一个小章节中我们声明了一个函数 `parser()`，相信聪明的读者已经实现了一个简单的小函数了吧，比如说像这样。

```cpp
int parser(const std::string& content)
{
    return (content[0] - '0') + (content[2] - '0');
}
```

现在我们来写一个简单的测试函数吧。测试函数是指用于测试代码的函数，它通常会对代码的各个部分进行测试，以确保代码的正确性。

写测试代码有很多好处，延伸一点的可以看附录（[附录 3. 软件测试](./附录_03_软件测试)）

例子：

```cpp
bool is_equal(int expect, int actual)
{
    if(expect == actual)
    {
        cout << "测试通过！" << endl;
        return true;
    }
    else
    {
        std::cerr << "期望值为: " << expect << "，";
        std::cerr << "但实际值为: " << actual << std::endl;
        return false;
    }
}
```

可能会有聪明的读者会问了：这是啥？这不是测试函数吧……

确实，不过大差不离。

std::cerr 是标准错误流，可以看作 cout（标准输出流）。它的用法和 cout 类似，但它主要是用于输出错误信息。

我们可以以上面这个函数为基本，写一个简单的测试用例。

```cpp
void test_number_add()
{
    is_equal(18, parser("9+9"));
    is_equal(100, parser("1+99"));
}
```

可以看出，我们添加了两个测试用例。虽然一眼就可以看出第二个在我们的实现中是错误的，因为我们给定操作的数的大小为小于 10 的自然数，但我们依旧应该把它写上。

最后在 main 函数中调用 test_number_add 函数。

```cpp
int main()
{
    test_number_add();
    return 0;
}
```

运行，得到的结果为：

```cpp
测试通过！
期望值为: 100，但实际值为: 10
```

第二个测试用例在我们的实现中相当与第一个测试用例，因此，我们将要进行一些改进。

在下一章节中我们会用到测试驱动开发的策略，附录附录（[附录 3. 软件测试](./附录_03_软件测试)）中对此进行了一定的讲解。
