# 6. 整型加法计算器

## 测试驱动开发战略

上一章节我们写了一个简单的，可以实现一位数之间加法的计算器。同时，我们也简单提到了测试驱动开发的策略。

测试驱动开发，即先编写测试，再写代码，直到代码可以通过测试。它可以增强我们对自己源码的信心，也可以完成要完成的任务。因此，需要写出尽可能覆盖范围广的测试。

聪明的读者肯定可以考虑到：百密必有一疏，过度依赖测试驱动开发的策略很有可能因为测试不够全面，导致测试过了但是还是出现 bug。

这里要说一下，测试驱动开发并不是保证一定不会有 bug，而是保证功能一定可以实现。这里的功能指的是可以通过测试的功能。并且，测试驱动开发要求人们必须写测试，而写测试用来验证代码是否合格是一个良好的习惯，测试驱动开发可以强制人们必须遵循好习惯。

因此，强烈推荐采用测试驱动开发的策略。

## 整型加减法

上回我们写了一个不能通过的测试用例：

```cpp
is_equal(100, parser("1+99"));
```

同样的，这也是一个不能通过的测试用例：

```cpp
is_equal(100, parser("99+1"));
```

出现这些问题的本质原因是我们并没有编写支持更多位数的解析函数，因此，我们需要改进目前的解析函数。

很显然，这相当与提出问题：怎么实现对字符串 `"x+y"` 的解析，x、y 为自然数，且没有空格等其它干扰。

不难发现，自然数可以非常大，所以我们这里规定结果在 int 类型的范围内（不过据说 int 类型在不同位数系统表现的大小不一样，虽然这目前不是很重要……那么类型就在四个字节以内吧……）。

那么思路就很简单了：

1. 遍历字符串，并将每个数字给存储起来，直到遇到加号，这时就完成了对第一个数字的解析。
2. 从加号开始遍历字符串，把第二个数也存储起来，直到遇到结束符。
3. 返回结果。

字符串的结束符通常是 `'\0'`，不过也可以根据字符串的长度进行判断，因为 cpp 中的字符串提供了 size() 函数来获得长度。

```cpp
int parser(const std::string& content)
{
    int left{};
    int tmp{};
    for(auto& c: content)
    {
        const int ascii_0 = int{'0'};
        if(c == '+')
        {
            left = tmp;
            tmp = 0;
        }
        else if(c == '\0')
        {
            break;
        }
        else
        {
            tmp *= 10;
            tmp = tmp + int{c} - ascii_0;
        }
    }
    return left + tmp;
}
```

运行之后如果可以通过测试，就意味着这些代码写对了。

### return 语句

return 语句可以放进 `else if(c == '\0')` 中，因为最后一个字符一定是 `'\0'`。但是事实上一般不建议这么写，万一真的出现了一个最后一个字符不是 `'\0'` 的字符串呢？这样函数就没有了返回值。因此需要将 return 语句提到外面来。

### const 常量

const 常量也能起到优化程序的作用，使用它是一个良好的习惯。

想象一下，你的代码中出现了一个奇怪的数字（魔数，Magic Number），没有人可以一目了然地知道这个数字是干什么的。因此我们可以给数字一个名字，即声明一个变量，使用该数字时就可以直接使用名字了，比如 `ascii_0` 意味着 0 的 ascii 码。

然而声明一个变量可能会在运行时占用资源（除非被编译器给优化了），还可能被一不小心修改了，因此可以使用常量来声明它。

示例中即使用 `‘0’` 代替 `ascii_0`，可读性依旧很高。但在实际中可能会有更复杂的情况。因此建议多将魔数转化为常量。

这还有一个好处：当以后可能要改变这些数字时，或者使它成为变量时，仅需要修改一处代码。

### 大括号类型转换

大括号类型转换，这是一个早在 cpp11 就出现的内容。早在 c 语言就有自动（隐式）类型转换和强制类型转换，当这两种较转换考验程序员的编程能力，一有疏忽就会出现意外（不安全的类型转换：如符点数转整数。而大括号转换是安全的类型转换（当出现不安全的类型转换时，会过不了编译）。因此建议使用大括号进行类型转化。

当然，这并不意味着不用大括号就一定不好，有时使用隐式转换也可以增强可读性。因此读者应该自己取舍。
